"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.goodbyeImage = exports.welcomeImage = exports.drawCard = exports.themes = exports.Gradient = void 0;
const canvas_1 = require("canvas");
const fs_1 = require("fs");
const path_1 = require("path");
var core_1 = require("@discord-card/core");
Object.defineProperty(exports, "Gradient", { enumerable: true, get: function () { return core_1.Gradient; } });
const production = true;
function getFontSize(str) {
    if (str.length < 18)
        return 30;
    return (600 * Math.pow(str.length, -1.05)).toFixed(0);
}
function toImage(image, name) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (image instanceof canvas_1.Canvas) {
            let img = new canvas_1.Image();
            img.src = image.toDataURL();
            return img;
        }
        else if (image instanceof canvas_1.Image)
            return image;
        else if (typeof image === 'string' || image instanceof Buffer)
            return yield (0, canvas_1.loadImage)(image);
        else
            throw new Error((_a = 'Invalid Image Format for: ' + name) !== null && _a !== void 0 ? _a : 'Image');
    });
}
const root = (0, path_1.join)(__dirname, '..', 'images');
exports.themes = {
    'dark': { color: '#ffffff', image: (0, path_1.join)(root, 'dark.png') },
    'circuit': { color: '#ffffff', image: (0, path_1.join)(root, 'circuit.png') },
    'code': { color: '#ffffff', image: (0, path_1.join)(root, 'code.png'), font: 'Source Sans Pro' },
};
var count = 0;
function snap(c) {
    if (!production)
        (0, fs_1.writeFileSync)(`./testing/snapshots/${count}.png`, c.toBuffer('image/png'));
    count++;
}
function drawCard(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    return __awaiter(this, void 0, void 0, function* () {
        const w = 700, h = 250;
        const canvas = (0, canvas_1.createCanvas)(w, h);
        const ctx = canvas.getContext('2d');
        ctx.w = ctx.width = w;
        ctx.h = ctx.height = h;
        //@ts-ignore
        let theme;
        let background;
        (_a = options.border) !== null && _a !== void 0 ? _a : (options.border = true);
        (_b = options.rounded) !== null && _b !== void 0 ? _b : (options.rounded = true);
        //Parsing the Theme
        if (typeof ((_c = options.theme) !== null && _c !== void 0 ? _c : 'code') === 'string') {
            theme = exports.themes[(_d = options.theme) !== null && _d !== void 0 ? _d : 'code'];
            if (!theme)
                throw new Error('Invalid theme, use: ' + Object.keys(exports.themes).join(' | '));
            background = yield (0, canvas_1.loadImage)(theme.image);
        }
        else
            throw new Error('Invalid theme, use: ' + Object.keys(exports.themes).join(' | '));
        if (options.background)
            background = yield toImage(options.background, 'Background');
        ctx.theme = theme;
        /** Border width */
        const b = 10; //Border
        //Background
        snap(canvas);
        if (options.rounded)
            ctx.roundRect(0, 0, w, h, h / 15);
        else
            ctx.rect(0, 0, w, h);
        ctx.clip();
        if (options.border) {
            ctx.drawImage(background, 0, 0, w, h);
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            ctx.globalAlpha = 1;
            ctx.blur(3);
        }
        snap(canvas);
        //Rounded Edges
        if (options.border) {
            if (options.rounded) {
                ctx.roundRect(b, b, w - 2 * b, h - 2 * b, h / 20);
            }
            else {
                ctx.rect(b, b, w - (2 * b), h - (2 * b));
            }
            ctx.clip();
        }
        else {
            if (options.rounded)
                ctx.roundRect(0, 0, w, h, h / 15).clip();
            else
                ctx.rect(0, 0, w, h);
        }
        var temp = background;
        if (options.blur) {
            var blur = (0, canvas_1.createCanvas)(w, h), blur_ctx = blur.getContext('2d');
            blur_ctx.drawImage(background, 0, 0, w, h);
            if (typeof options.blur === 'boolean')
                blur_ctx.blur(3);
            else
                blur_ctx.blur(options.blur);
            temp = blur;
        }
        if (options.border)
            ctx.drawImage(temp, b, b, w - b * 2, h - b * 2);
        else
            ctx.drawImage(temp, 0, 0, w, h);
        snap(canvas);
        //Setting Styles
        ctx.fillStyle = ((_f = (_e = options.text) === null || _e === void 0 ? void 0 : _e.color) !== null && _f !== void 0 ? _f : theme.color).toString(ctx);
        //ctx.strokeStyle = theme.color.toString(ctx);
        ctx.font = '30px ' + ((_j = ((_h = (_g = options.text) === null || _g === void 0 ? void 0 : _g.font) !== null && _h !== void 0 ? _h : theme.font)) !== null && _j !== void 0 ? _j : 'sans-serif', 'segoe-ui-emoji');
        //Drawing
        //Title
        ctx.changeFontSize('30px')
            .fillText((_l = (_k = options.text) === null || _k === void 0 ? void 0 : _k.title) !== null && _l !== void 0 ? _l : '', ctx.width / 2.7, ctx.height / 3.5);
        //Text
        ctx.changeFontSize(getFontSize((_o = (_m = options.text) === null || _m === void 0 ? void 0 : _m.text) !== null && _o !== void 0 ? _o : '') + 'px')
            .fillText((_q = (_p = options.text) === null || _p === void 0 ? void 0 : _p.text) !== null && _q !== void 0 ? _q : '', ctx.width / 2.7, ctx.height / 1.8);
        //Subtitle
        ctx.changeFontSize('25px')
            .fillText((_s = (_r = options.text) === null || _r === void 0 ? void 0 : _r.subtitle) !== null && _s !== void 0 ? _s : '', ctx.width / 2.7, ctx.height / 1.3);
        //Avatar Image
        const radius = h / 2.5;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(h / 2, h / 2, radius, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.clip();
        const { avatar } = options;
        if (avatar) {
            const { image: avatarImage, outlineWidth, outlineColor } = avatar;
            if (avatarImage) {
                ctx.drawImage(yield toImage(avatarImage), ((h / 2) - radius) + ((_t = avatar.outlineWidth) !== null && _t !== void 0 ? _t : 0), //x
                ((h / 2) - radius) + ((_u = avatar.outlineWidth) !== null && _u !== void 0 ? _u : 0), //y
                (radius * 2) - ((_v = avatar.outlineWidth) !== null && _v !== void 0 ? _v : 0) * 2, //width
                (radius * 2) - ((_w = avatar.outlineWidth) !== null && _w !== void 0 ? _w : 0) * 2 //height
                );
            }
            if (outlineWidth) {
                ctx.beginPath();
                ctx.arc(h / 2, h / 2, radius - (outlineWidth / 2), 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.lineWidth = outlineWidth;
                ctx.strokeStyle = ((_x = outlineColor !== null && outlineColor !== void 0 ? outlineColor : theme.color) !== null && _x !== void 0 ? _x : '#fff').toString(ctx);
                ctx.stroke();
            }
        }
        snap(canvas);
        return canvas.toBuffer('image/png');
    });
}
exports.drawCard = drawCard;
function welcomeImage(member, options = {}) {
    var _a, _b, _c, _d, _e, _f;
    var _g, _h, _j, _k;
    return __awaiter(this, void 0, void 0, function* () {
        const opts = Object.assign({}, options);
        (_a = opts.text) !== null && _a !== void 0 ? _a : (opts.text = {});
        (_b = opts.avatar) !== null && _b !== void 0 ? _b : (opts.avatar = {});
        (_c = (_g = opts.text).title) !== null && _c !== void 0 ? _c : (_g.title = `Welcome to this server,`);
        (_d = (_h = opts.text).text) !== null && _d !== void 0 ? _d : (_h.text = `${member.user.tag}!`);
        (_e = (_j = opts.text).subtitle) !== null && _e !== void 0 ? _e : (_j.subtitle = `MemberCount: ${member.guild.memberCount}`);
        (_f = (_k = opts.avatar).image) !== null && _f !== void 0 ? _f : (_k.image = yield (0, canvas_1.loadImage)(member.user.displayAvatarURL({ format: 'png' })));
        return yield drawCard(opts);
    });
}
exports.welcomeImage = welcomeImage;
function goodbyeImage(member, options = {}) {
    var _a, _b, _c, _d, _e;
    var _f, _g, _h;
    return __awaiter(this, void 0, void 0, function* () {
        const opts = Object.assign({}, options);
        (_a = opts.text) !== null && _a !== void 0 ? _a : (opts.text = {});
        (_b = opts.avatar) !== null && _b !== void 0 ? _b : (opts.avatar = {});
        (_c = (_f = opts.text).title) !== null && _c !== void 0 ? _c : (_f.title = `Goodbye,`);
        (_d = (_g = opts.text).text) !== null && _d !== void 0 ? _d : (_g.text = `${member.user.tag}!`);
        (_e = (_h = opts.avatar).image) !== null && _e !== void 0 ? _e : (_h.image = yield (0, canvas_1.loadImage)(member.user.displayAvatarURL({ format: 'png' })));
        return yield drawCard(opts);
    });
}
exports.goodbyeImage = goodbyeImage;
//# sourceMappingURL=index.js.map